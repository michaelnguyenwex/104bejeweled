<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10-4 Match Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            gap: 2px;
            background-color: #333;
            padding: 10px;
            border-radius: 10px;
        }
        .gem {
            width: 60px;
            height: 60px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .gem img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5px;
            transition: transform 0.2s;
        }
        .gem:hover img {
            transform: scale(1.1);
        }
        .explosion {
            animation: explosionEffect 0.5s ease-out forwards;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 165, 0, 0) 70%);
            border-radius: 5px;
            z-index: 1;
            pointer-events: none;
        }
        @keyframes explosionEffect {
            0% { transform: scale(0); opacity: 1; box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
            50% { transform: scale(1.5); opacity: 0.7; box-shadow: 0 0 30px rgba(255, 165, 0, 0.6); }
            100% { transform: scale(2); opacity: 0; box-shadow: none; }
        }
        .removing img {
            animation: removeGem 0.5s ease-out forwards;
        }
        @keyframes removeGem {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(0.8); opacity: 0.3; }
        }
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #ffeb3b, #ff9800);
            border-radius: 50%;
            animation: particleAnimation 0.5s ease-out forwards;
            z-index: 2;
            pointer-events: none;
        }
        @keyframes particleAnimation {
            0% { transform: scale(0) translate(0, 0); opacity: 1; }
            50% { transform: scale(1.2) translate(calc(var(--particle-x) * 0.5), calc(var(--particle-y) * 0.5)); opacity: 0.8; }
            100% { transform: scale(1) translate(var(--particle-x), var(--particle-y)); opacity: 0; }
        }
        #score {
            font-size: 24px;
            margin: 20px;
        }
        .selected {
            border: 2px solid yellow;
        }
    </style>
</head>
<body>
    <h1>10-4 Match Game</h1>
    <div id="score">Score: <span id="score-value">0</span></div>
    <div id="game-board"></div>

    <script src="images-base64.js"></script>
    <script src="match-sound.js"></script>
    <script>
        // Wait for all resources to load before starting the game
        window.onload = function() {
            // Validate GEM_IMAGES is loaded
            if (typeof GEM_IMAGES === 'undefined') {
                console.error("GEM_IMAGES is not defined. Please check images-base64.js");
                alert("Failed to load game images. Please refresh the page.");
                return;
            }

            // Game variables
            const GEM_KEYS = Object.keys(GEM_IMAGES); // Get keys directly from GEM_IMAGES
            let board = [];
            let score = 0;
            let selectedGem = null;
            
            const gameBoard = document.getElementById('game-board');
            const scoreDisplay = document.getElementById('score-value');

            // Initialize sound with fallbacks
            let matchSound;
            
            // Try to create audio with different sources
            function createAudio() {
                // Create audio element with multiple sources for better compatibility
                matchSound = document.createElement('audio');
                matchSound.volume = 0.5;
                
                // Try multiple different sound formats
                const sources = [
                    'https://freesound.org/data/previews/387/387232_5121236-lq.mp3',
                    'https://www.soundjay.com/buttons/sounds/button-09.mp3',
                    'https://www.soundjay.com/buttons/sounds/button-4.mp3'
                ];
                
                for (const src of sources) {
                    const sourceElement = document.createElement('source');
                    sourceElement.src = src;
                    sourceElement.type = src.endsWith('.mp3') ? 'audio/mpeg' : 'audio/wav';
                    matchSound.appendChild(sourceElement);
                }
                
                // Add to document to preload (but hidden)
                matchSound.style.display = 'none';
                document.body.appendChild(matchSound);
                
                // Fallback method using AudioContext if available
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    const audioContext = new AudioContext();
                    console.log("AudioContext available:", audioContext.state);
                } catch (e) {
                    console.log("AudioContext not supported in this browser");
                }
            }
            
            // Initialize audio
            createAudio();

            // Initialize the game board
            function initBoard() {
                board = [];
                for (let i = 0; i < 8; i++) {
                    board[i] = [];
                    for (let j = 0; j < 8; j++) {
                        board[i][j] = getRandomGem();
                    }
                }
                renderBoard();
                checkMatches();
            }

            // Get a random gem type
            function getRandomGem() {
                const index = Math.floor(Math.random() * GEM_KEYS.length);
                return GEM_KEYS[index];
            }

            // Check if a gem is marked for removal
            function isMarkedForRemoval(gemValue) {
                return gemValue && typeof gemValue === 'string' && gemValue.startsWith('marked-for-removal:');
            }

            // Render the game board with images
            function renderBoard() {
                gameBoard.innerHTML = '';
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const gem = document.createElement('div');
                        gem.classList.add('gem');
                        gem.dataset.row = i;
                        gem.dataset.col = j;
                        gem.dataset.type = board[i][j]; // Store gem type for matching
                        
                        const img = document.createElement('img');
                        const gemKey = board[i][j];
                        
                        // Handle marked gems
                        let actualKey = gemKey;
                        if (isMarkedForRemoval(gemKey)) {
                            // Extract the original gem key
                            actualKey = gemKey.substring('marked-for-removal:'.length);
                            gem.classList.add('removing'); // Add class for visual effect
                        }
                        
                        // Validate the image exists for this key
                        if (GEM_IMAGES[actualKey]) {
                            img.src = GEM_IMAGES[actualKey];
                            // If it's marked for removal, apply opacity
                            if (isMarkedForRemoval(gemKey)) {
                                img.style.opacity = '0.3';
                            }
                        } else {
                            console.error(`Missing image for gem key: ${gemKey}`);
                            img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAEElEQVR42u3BAQEAAACCIP+vbkhAAQAAAO8GECAAAZf3V9cAAAAASUVORK5CYII='; // Fallback black image
                        }
                        
                        if (selectedGem && selectedGem.row === i && selectedGem.col === j) {
                            gem.classList.add('selected');
                        }
                        
                        gem.appendChild(img);
                        gem.addEventListener('click', handleGemClick);
                        gameBoard.appendChild(gem);
                    }
                }
            }

            // Handle gem clicks
            function handleGemClick(event) {
                // Make sure we get the gem element, not the image inside it
                const gemElement = event.target.closest('.gem');
                const row = parseInt(gemElement.dataset.row);
                const col = parseInt(gemElement.dataset.col);

                if (!selectedGem) {
                    selectedGem = { row, col };
                    gemElement.classList.add('selected');
                } else {
                    const prevRow = selectedGem.row;
                    const prevCol = selectedGem.col;

                    // Clear previous selection
                    const prevSelected = document.querySelector(`.gem[data-row="${prevRow}"][data-col="${prevCol}"]`);
                    if (prevSelected) {
                        prevSelected.classList.remove('selected');
                    }

                    // Check if the clicked gem is adjacent to the selected gem
                    if (isAdjacent(row, col, prevRow, prevCol)) {
                        swapGems(row, col, prevRow, prevCol);
                        if (checkMatches()) {
                            updateScore(100);
                        } else {
                            // Swap back if no matches
                            swapGems(row, col, prevRow, prevCol);
                        }
                        selectedGem = null;
                        renderBoard();
                    } else {
                        // Select the new gem
                        selectedGem = { row, col };
                        gemElement.classList.add('selected');
                    }
                }
            }

            // Check if two gems are adjacent
            function isAdjacent(row1, col1, row2, col2) {
                return (Math.abs(row1 - row2) === 1 && col1 === col2) || 
                       (Math.abs(col1 - col2) === 1 && row1 === row2);
            }

            // Swap two gems
            function swapGems(row1, col1, row2, col2) {
                [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];
            }

            // Check for matches and remove them
            function checkMatches() {
                let hasMatches = false;

                // Check horizontal matches
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8 - 2; j++) {
                        if (board[i][j] !== null && board[i][j] === board[i][j + 1] && board[i][j] === board[i][j + 2]) {
                            hasMatches = true;
                            // Mark these positions for removal but don't remove immediately
                            for (let k = j; k < j + 3; k++) {
                                const gem = document.querySelector(`.gem[data-row="${i}"][data-col="${k}"]`);
                                if (gem) {
                                    const explosion = document.createElement('div');
                                    explosion.classList.add('explosion');
                                    gem.appendChild(explosion);
                                    createParticles(gem);
                                    // Just fade the image but keep it visible for the animation
                                    gem.querySelector('img').style.opacity = '0.3';
                                }
                                // Mark for removal instead of setting to null immediately
                                board[i][k] = 'marked-for-removal:' + board[i][k];
                            }
                        }
                    }
                }

                // Check vertical matches
                for (let j = 0; j < 8; j++) {
                    for (let i = 0; i < 8 - 2; i++) {
                        if (board[i][j] !== null && board[i][j] === board[i + 1][j] && board[i][j] === board[i + 2][j]) {
                            hasMatches = true;
                            // Mark these positions for removal but don't remove immediately
                            for (let k = i; k < i + 3; k++) {
                                const gem = document.querySelector(`.gem[data-row="${k}"][data-col="${j}"]`);
                                if (gem) {
                                    const explosion = document.createElement('div');
                                    explosion.classList.add('explosion');
                                    gem.appendChild(explosion);
                                    createParticles(gem);
                                    // Just fade the image but keep it visible for the animation
                                    gem.querySelector('img').style.opacity = '0.3';
                                }
                                // Mark for removal instead of setting to null immediately
                                board[k][j] = 'marked-for-removal:' + board[k][j];
                            }
                        }
                    }
                }

                if (hasMatches) {
                    // Play sound with fallback methods
                    playMatchSound();
                    
                    // Wait for the explosion animation to finish before dropping gems
                    setTimeout(() => {
                        // Actually remove all marked gems
                        for (let i = 0; i < 8; i++) {
                            for (let j = 0; j < 8; j++) {
                                if (board[i][j] && typeof board[i][j] === 'string' && 
                                    board[i][j].startsWith('marked-for-removal:')) {
                                    board[i][j] = null;
                                }
                            }
                        }
                        dropGems();
                        setTimeout(checkMatches, 100);
                    }, 500);
                }

                return hasMatches;
            }
            
            // Play match sound with fallbacks
            function playMatchSound() {
                // Try the HTML5 Audio element first
                if (matchSound) {
                    try {
                        matchSound.currentTime = 0;
                        const playPromise = matchSound.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                console.log('Sound play failed, trying alternative:', error);
                                playFallbackSound();
                            });
                        }
                    } catch (e) {
                        console.log('Error playing sound:', e);
                        playFallbackSound();
                    }
                } else {
                    playFallbackSound();
                }
            }
            
            // Fallback sound method using beep
            function playFallbackSound() {
                // Try oscillator beep first
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    const context = new AudioContext();
                    const oscillator = context.createOscillator();
                    const gainNode = context.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440; // A4 note
                    gainNode.gain.value = 0.1;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(context.destination);
                    
                    oscillator.start(0);
                    oscillator.stop(context.currentTime + 0.1); // Short beep
                } catch (e) {
                    console.log('Oscillator fallback sound failed:', e);
                    // Try the base64 encoded sound from match-sound.js
                    if (typeof playBase64Sound === 'function') {
                        playBase64Sound();
                    }
                }
            }

            // Create particle effects
            function createParticles(gem) {
                const particleCount = 8; // Increased number of particles
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    particle.style.left = `${Math.random() * 60}px`;
                    particle.style.top = `${Math.random() * 60}px`;
                    particle.style.animationDelay = `${Math.random() * 0.2}s`;
                    const angle = Math.random() * Math.PI * 2; // Full 360 degrees in radians
                    const distance = Math.random() * 30 + 10; // Increased distance
                    particle.style.setProperty('--particle-x', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--particle-y', `${Math.sin(angle) * distance}px`);
                    gem.appendChild(particle);
                    setTimeout(() => {
                        if (gem.contains(particle)) { // Check if particle still exists in DOM
                            gem.removeChild(particle);
                        }
                    }, 500);
                }
            }

            // Drop gems to fill empty spaces
            function dropGems() {
                for (let j = 0; j < 8; j++) {
                    for (let i = 8 - 1; i >= 0; i--) {
                        if (board[i][j] === null) {
                            // Look for a gem above to drop down
                            for (let k = i - 1; k >= 0; k--) {
                                if (board[k][j] !== null) {
                                    board[i][j] = board[k][j];
                                    board[k][j] = null;
                                    break;
                                }
                            }
                            // If no gems above, create a new one
                            if (board[i][j] === null) {
                                board[i][j] = getRandomGem();
                            }
                        }
                    }
                }
                renderBoard();
            }

            // Update the score
            function updateScore(points) {
                score += points;
                scoreDisplay.textContent = score;
            }

            // Start the game
            console.log("Starting game with gem keys:", GEM_KEYS);
            initBoard();
        } // End of window.onload - no semicolon here
    </script>
</body>
</html>
